function bggammamod_rayleighbox(data,Laps,Track)
%BGGAMMAMOD_RAYLEIGHBOX   Modulation of gamma power by theta phase.
%   BGGAMMAMOD_RAYLEIGHBOX(DATA,LAPS) compares the modulation of gamma power
%   by theta (4-12 Hz) phase in the ipsilateral and in the contralateral
%   hippocampus. Low gamma (30-40 Hz) and high gamma (80-120 Hz) are
%   calculated separately. Phase and amplitude values are generated by
%   Hilbert transformation. Coupling is detected by Rayleigh's test.
%
%   BGGAMMAMOD_RAYLEIGHBOX calculates group data for crossmodulation
%   values. Wavelet power and crosswavelet power in the relevant frequency
%   bands are also analyzed.
%
%   See also BGGAMMAMOD_RAYLEIGH2.

% Results directory
global DATAPATH
resdir = [DATAPATH 'Wheel2\g01_m13\Gammamod_rayleighbox4\4_10\'];
rat = 'g01_m13';
mm = pwd;
cd(resdir)

% Laps
lap_start = find(Laps.StartLaps)';
lap_start = find(diff(Laps.MazeSection==1)==1)';
lap_end = [lap_start(2:end)-1 size(Laps.TrialType,1)];
lap_mazesection = round(resample(Laps.MazeSection,4,5));
lap_center = round((lap_start+lap_end)/2);
lap_type = Laps.TrialType(lap_center);
lap_behav = Laps.BehavType(lap_center);
lap_start = round(lap_start*4/5);  % indices are transformed to match new samp. rate
lap_end = [lap_start(2:end)-1 size(data,2)];
lap_center = round((lap_start+lap_end)/2);
lt = length(lap_start);
trackx = round(resample(Track.X,4,5));      % spatial coordinates
tracky = round(resample(Track.Y,4,5));
[trackx tracky] = poscorr(trackx',tracky');
% lt = 1;
% error_WE = [];
% futureL_WE = [];
% futureR_WE = [];

% Main
modix1glR = zeros(lt,10) * NaN;     % initialization
modix2glR = zeros(lt,10) * NaN;
modix3glR = zeros(lt,10) * NaN;
modix4glR = zeros(lt,10) * NaN;
modix1glL = zeros(lt,10) * NaN;
modix2glL = zeros(lt,10) * NaN;
modix3glL = zeros(lt,10) * NaN;
modix4glL = zeros(lt,10) * NaN;
modix1ghR = zeros(lt,10) * NaN;
modix2ghR = zeros(lt,10) * NaN;
modix3ghR = zeros(lt,10) * NaN;
modix4ghR = zeros(lt,10) * NaN;
modix1ghL = zeros(lt,10) * NaN;
modix2ghL = zeros(lt,10) * NaN;
modix3ghL = zeros(lt,10) * NaN;
modix4ghL = zeros(lt,10) * NaN;
tpixR = zeros(lt,10) * NaN;
lgpixR = zeros(lt,10) * NaN;
hgpixR = zeros(lt,10) * NaN;
tpixL = zeros(lt,10) * NaN;
lgpixL = zeros(lt,10) * NaN;
hgpixL = zeros(lt,10) * NaN;
tpixC = zeros(lt,10) * NaN;
lgpixC = zeros(lt,10) * NaN;
hgpixC = zeros(lt,10) * NaN;
crossmod_timestampsR = [];
crossmod_timestampsL = [];
normcrossmodR = cell(1,lt);
normcrossmodR_index = cell(1,lt);
normcrossmodL = cell(1,lt);
normcrossmodL_index = cell(1,lt);
normtpdR = cell(1,lt);
normtpdR_index = cell(1,lt);
normtpdL = cell(1,lt);
normtpdL_index = cell(1,lt);
for k = 1:lt   % 'lap' cycle
    k
    if ~isequal(lap_behav(k),1) || isequal(lap_type(k),0)
        continue
    end
    tS = lap_start(k);      % get trial EEG
    tE = lap_end(k);
    eegR = data(10,tS:tE);   % shank: 10
    eegL = data(4,tS:tE);   % shank: 4
    maze_section = lap_mazesection(tS:tE);
    laptrackx = zero2nan(trackx(tS:tE));
    laptracky = zero2nan(tracky(tS:tE));
    
% Filter and Hilbert-transform
    sr = 1000;
    nqf = sr / 2;
    flt = fir1(1024,[4 12]/nqf,'band');      % bandpass filtering: theta frequency band bounderies: 8-10 Hz
    if length(eegR) < 3 * 1024
        continue
    end
    feeg_thetaR = filtfilt(flt,1,eegR);
    feeg_thetaR = (feeg_thetaR - mean(feeg_thetaR)) / std(feeg_thetaR);
    feeg_thetaL = filtfilt(flt,1,eegL);
    feeg_thetaL = (feeg_thetaL - mean(feeg_thetaL)) / std(feeg_thetaL);
    hilb_thphaseR = angle(hilbert(feeg_thetaR));    % Hilbert-transform
    hilb_thphaseL = angle(hilbert(feeg_thetaL));
    flt = fir1(1024,[30 40]/nqf,'band');      % bandpass filtering: low gamma frequency band bounderies: 30-40 Hz
    feeg_lowR = filtfilt(flt,1,eegR);
    feeg_lowR = (feeg_lowR - mean(feeg_lowR)) / std(feeg_lowR);
    feeg_lowL = filtfilt(flt,1,eegL);
    feeg_lowL = (feeg_lowL - mean(feeg_lowL)) / std(feeg_lowL);
    hilb_glabsR = abs(hilbert(feeg_lowR));
    hilb_glabsL = abs(hilbert(feeg_lowL));
    flt = fir1(1024,[80 120]/nqf,'band');      % bandpass filtering: high gamma frequency band bounderies: 80-120 Hz
    feeg_highR = filtfilt(flt,1,eegR);
    feeg_highR = (feeg_highR - mean(feeg_highR)) / std(feeg_highR);
    feeg_highL = filtfilt(flt,1,eegL);
    feeg_highL = (feeg_highL - mean(feeg_highL)) / std(feeg_highL);
    hilb_ghabsR = abs(hilbert(feeg_highR));
    hilb_ghabsL = abs(hilbert(feeg_highL));
    
% Wavelet
    [waveR f] = eeg_wavelet(eegR,sr);   % EEG sampled on 1000 Hz
    [waveL f] = eeg_wavelet(eegL,sr);
    wave_cross = waveR .* conj(waveL);
    waveaR = abs(waveR) .^ 2;
    waveaL = abs(waveL) .^ 2;
    wavea_cross = abs(wave_cross) .^ 2;     % crosswavelet
    clear waveR waveL wave_cross
    pwind1t = find(f>4,1,'last');    % frequency band bounderies
    pwind2t = find(f<12,1,'first');
    pwind1lg = find(f>30,1,'last');
    pwind2lg = find(f<40,1,'first');
    pwind1hg = find(f>80,1,'last');
    pwind2hg = find(f<120,1,'first');
    pwind1d = find(f>0.5,1,'last');
    pwind2d = find(f<4,1,'first');
    tpowerR = mean(waveaR(pwind2t:pwind1t,:));      % wavelet power
    tpowerL = mean(waveaL(pwind2t:pwind1t,:));
    tpowerC = mean(wavea_cross(pwind2t:pwind1t,:));     % crosswavelet power
    lgpowerR = mean(waveaR(pwind2lg:pwind1lg,:));
    lgpowerL = mean(waveaL(pwind2lg:pwind1lg,:));
    lgpowerC = mean(wavea_cross(pwind2lg:pwind1lg,:));
    hgpowerR = mean(waveaR(pwind2hg:pwind1hg,:));
    hgpowerL = mean(waveaL(pwind2hg:pwind1hg,:));
    hgpowerC = mean(wavea_cross(pwind2hg:pwind1hg,:));
    dpowerR = mean(waveaR(pwind2d:pwind1d,:));
    dpowerL = mean(waveaL(pwind2d:pwind1d,:));
    tpdR = tpowerR ./ dpowerR;  % theta power / delta power
    tpdL = tpowerL ./ dpowerL;
    thetaR = hilb_thphaseR; % no normalization!
    thetaL = hilb_thphaseL;
    gammalR = hilb_glabsR;
    gammalL = hilb_glabsL;
    gammahR = hilb_ghabsR;
    gammahL = hilb_ghabsL;

% Rayleigh-test
    [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL pglR pglL pghR pghL] = ...
        lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR,gammahL,trackx,tracky,1000,10);
    
% Wavelet images & spatial plots
    tm = linspace(0,tE-tS,length(MItRglR));
    tmm = linspace(0,tE-tS,length(maze_section));
    HR = figure;        % save wavelet images
    imagesc(waveaR)
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItLglR - MItRglR;
    plot(tm,60-cfdf,'c.-')      % imagesc plots y axis downwards! - significant crossmod. is up
    hold on
    cfdf(isnan(pglR)|pglR>0.01) = NaN;
    plot(tm,60-cfdf,'y.-')
    b_rescaleaxis('Y',f)
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
    b_zoomset_for_wavelet
    
    Hspp = figure;
    plot(laptrackx,laptracky,'Color',[0.7 0.7 0.7])
    hold on
    inx = find(~isnan(cfdf)&cfdf>0);
    plot(linterp(tmm,laptrackx,tm(inx)),linterp(tmm,laptracky,tm(inx)),'r.')
    crossmod_timestampsR = [crossmod_timestampsR tm(inx)+tS-1];
    cd('spatial_plot')
    fn = [rat '_t' num2str(k) '_HsppR.fig'];
    saveas(Hspp,fn)
    cd ..
    
    HL = figure;
    imagesc(waveaL)
    b_rescaleaxis('Y',f(f>0.5))
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
%     setappdata(gca,'scalex',tmm)
%     setappdata(gca,'scaley',f(f>0.5))
%     b_zoomset_for_wavelet
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItRglL - MItLglL;
    plot(tm,60-cfdf,'c.-')
    hold on
    cfdf(isnan(pglL)|pglL>0.01) = NaN;
    plot(tm,60-cfdf,'y.-')
    
    Hspp = figure;
    plot(laptrackx,laptracky,'Color',[0.7 0.7 0.7])
    hold on
    inx = find(~isnan(cfdf)&cfdf>0);
    plot(linterp(tmm,laptrackx,tm(inx)),linterp(tmm,laptracky,tm(inx)),'r.')
    crossmod_timestampsL = [crossmod_timestampsL tm(inx)+tS-1];
    cd('spatial_plot')
    fn = [rat '_t' num2str(k) '_HsppL.fig'];
    saveas(Hspp,fn)
    cd ..
    
    HC = figure;
    imagesc(wavea_cross)
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItLglR - MItRglR;
    plot(tm,60-cfdf,'c.-')
    hold on
    cfdf(isnan(pglR)|pglR>0.01) = NaN;
    plot(tm,60-cfdf,'y.-')
    b_rescaleaxis('Y',f)
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
    b_zoomset_for_wavelet
    cd('wavelet')
    fn = [rat '_t' num2str(k) '_waveR.jpg'];
    saveas(HR,fn)
    fn = [rat '_t' num2str(k) '_waveL.jpg'];
    saveas(HL,fn)
    fn = [rat '_t' num2str(k) '_waveC.jpg'];
    saveas(HC,fn)
    close(HR,HL,HC)
    close all
    cd ..
    
% Calculate cross-modulation and wavelet power for maze segments
    for mseg = 1:10
        inx = find(maze_section==mseg);     % wavelet and crosswavelet power for maze segments
        tpixR(k,mseg) = nanmean(tpowerR(inx));
        lgpixR(k,mseg) = nanmean(lgpowerR(inx));
        hgpixR(k,mseg) = nanmean(hgpowerR(inx));
        tpixL(k,mseg) = nanmean(tpowerL(inx));
        lgpixL(k,mseg) = nanmean(lgpowerL(inx));
        hgpixL(k,mseg) = nanmean(hgpowerL(inx));
        tpixC(k,mseg) = nanmean(tpowerC(inx));
        lgpixC(k,mseg) = nanmean(lgpowerC(inx));
        hgpixC(k,mseg) = nanmean(hgpowerC(inx));
        
        cfdf = MItLglR - MItRglR;   % cross-modulation for maze segments; low gamma, right
        cfdf2 = cfdf;
        cfdf2(isnan(pglR)|pglR>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1glR(k,mseg) = nanmean(mcf);       % all values
        modix2glR(k,mseg) = nanmean(mcf2);      % > 0 values
        modix3glR(k,mseg) = nanmean(mcf3);      % significant
        modix4glR(k,mseg) = nanmean(mcf4);      % significant and > 0
        if mseg == 7 || mseg == 8
            lsne = sne(2,:) - sne(1,:);     % find the longest segment
            sne(:,lsne<10) = [];
            lsne = sne(2,:) - sne(1,:);
            mxi = find(lsne==max(lsne));
            fsg1 = sne(1,mxi);
            fsg2 = sne(2,mxi);
            if ~isempty(fsg1)
                inx2 = find(tm>tmm(fsg1)&tm<tmm(fsg2));
                mcf3 = cfdf2(inx2);
                pnc = mcf3;
                pnc(pnc<=0) = NaN;
                normcrossmodR{k} = pnc;
                normcrossmodR_index{k} = (inx2 - min(inx2)) / (max(inx2) - min(inx2));

                normtpdR{k} = tpdR(fsg1:fsg2);
                normtpdR_index{k} = (0:(fsg2-fsg1)) / (fsg2 - fsg1);
            end
        end
        
        cfdf = MItRglL - MItLglL;       % low gamma, left
        cfdf2 = cfdf;
        cfdf2(isnan(pglL)|pglL>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1glL(k,mseg) = nanmean(mcf);
        modix2glL(k,mseg) = nanmean(mcf2);
        modix3glL(k,mseg) = nanmean(mcf3);
        modix4glL(k,mseg) = nanmean(mcf4);
        if mseg == 7 || mseg == 8
            lsne = sne(2,:) - sne(1,:);     % find the longest segment
            sne(:,lsne<10) = [];
            lsne = sne(2,:) - sne(1,:);
            mxi = find(lsne==max(lsne));
            fsg1 = sne(1,mxi);
            fsg2 = sne(2,mxi);
            if ~isempty(fsg1)
                inx2 = find(tm>tmm(fsg1)&tm<tmm(fsg2));
                mcf3 = cfdf2(inx2);
                pnc = mcf3;
                pnc(pnc<=0) = NaN;
                normcrossmodL{k} = pnc;
                normcrossmodL_index{k} = (inx2 - min(inx2)) / (max(inx2) - min(inx2));

                normtpdL{k} = tpdL(fsg1:fsg2);
                normtpdL_index{k} = (0:(fsg2-fsg1)) / (fsg2 - fsg1);
            end
        end
        
        cfdf = MItLghR - MItRghR;       % high gamma, right
        cfdf2 = cfdf;
        cfdf2(isnan(pghR)|pghR>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1ghR(k,mseg) = nanmean(mcf);
        modix2ghR(k,mseg) = nanmean(mcf2);
        modix3ghR(k,mseg) = nanmean(mcf3);
        modix4ghR(k,mseg) = nanmean(mcf4);
        
        cfdf = MItRghL - MItLghL;       % high gamma, left
        cfdf2 = cfdf;
        cfdf2(isnan(pghL)|pghL>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1ghL(k,mseg) = nanmean(mcf);
        modix2ghL(k,mseg) = nanmean(mcf2);
        modix3ghL(k,mseg) = nanmean(mcf3);
        modix4ghL(k,mseg) = nanmean(mcf4);
    end
    
%     switch lap_type(k)
%         case {3,4}
%             cd error
% 
%         case 2
%             cd futureL
% 
%         case 1
%             cd futureR
% 
%         otherwise
%             keyboard
%     end
%     cd ..
end

% Normalized reward segments
save temp.mat
lrs = 100;
lims1 = 0:1/lrs:(1-1/lrs);
lims2 = 1/lrs:1/lrs:1;
nrsR_cm = zeros(1,lrs);
nrsL_cm = zeros(1,lrs);
ntpdR = zeros(1,lrs);
ntpdL = zeros(1,lrs);
for k = 1:lt
    for t = 1:lrs
        lim1 = lims1(t);
        lim2 = lims2(t);
        linx = find(normcrossmodR_index{k}>lim1&normcrossmodR_index{k}<lim2);
        nrsR_cm(t) = nrsR_cm(t) + nan2zero(nanmean(normcrossmodR{k}(linx))) / lt;
        linx = find(normcrossmodL_index{k}>lim1&normcrossmodL_index{k}<lim2);
        nrsL_cm(t) = nrsL_cm(t) + nan2zero(nanmean(normcrossmodL{k}(linx))) / lt;
        linx = find(normtpdR_index{k}>lim1&normtpdR_index{k}<lim2);
        ntpdR(t) = ntpdR(t) + nan2zero(nanmean(normtpdR{k}(linx))) / lt;
        linx = find(normtpdL_index{k}>lim1&normtpdL_index{k}<lim2);
        ntpdL(t) = ntpdL(t) + nan2zero(nanmean(normtpdL{k}(linx))) / lt;
    end
end
HnR = figure;
plot(nrsR_cm,'k')
hold on
plot(ntpdR,'k:')
fn = [rat '_NormCrossModR.fig'];
saveas(HnR,fn)
HnL = figure;
plot(nrsL_cm,'k')
hold on
plot(ntpdL,'k:')
fn = [rat '_NormCrossModL.fig'];
saveas(HnL,fn)

% Plot and save
vv = modix1glR;     % cross-modulation; low gamma, right
H = plotsave(vv);
fn = [rat '_XMOD1glR.fig'];
saveas(H,fn)
vv = modix2glR;
H = plotsave(vv);
fn = [rat '_XMOD2glR.fig'];
saveas(H,fn)
vv = modix3glR;
H = plotsave(vv);
fn = [rat '_XMOD3glR.fig'];
saveas(H,fn)
vv = modix4glR;
H = plotsave(vv);
fn = [rat '_XMOD4glR.fig'];
saveas(H,fn)

vv = modix1glL;     % low gamma, left
H = plotsave(vv);
fn = [rat '_XMOD1glL.fig'];
saveas(H,fn)
vv = modix2glL;
H = plotsave(vv);
fn = [rat '_XMOD2glL.fig'];
saveas(H,fn)
vv = modix3glL;
H = plotsave(vv);
fn = [rat '_XMOD3glL.fig'];
saveas(H,fn)
vv = modix4glL;
H = plotsave(vv);
fn = [rat '_XMOD4glL.fig'];
saveas(H,fn)

vv = modix1ghR;     % high gamma, right
H = plotsave(vv);
fn = [rat '_XMOD1ghR.fig'];
saveas(H,fn)
vv = modix2ghR;
H = plotsave(vv);
fn = [rat '_XMOD2ghR.fig'];
saveas(H,fn)
vv = modix3ghR;
H = plotsave(vv);
fn = [rat '_XMOD3ghR.fig'];
saveas(H,fn)
vv = modix4ghR;
H = plotsave(vv);
fn = [rat '_XMOD4ghR.fig'];
saveas(H,fn)

vv = modix1ghL;     % high gamma, left
H = plotsave(vv);
fn = [rat '_XMOD1ghL.fig'];
saveas(H,fn)
vv = modix2ghL;
H = plotsave(vv);
fn = [rat '_XMOD2ghL.fig'];
saveas(H,fn)
vv = modix3ghL;
H = plotsave(vv);
fn = [rat '_XMOD3ghL.fig'];
saveas(H,fn)
vv = modix4ghL;
H = plotsave(vv);
fn = [rat '_XMOD4ghL.fig'];
saveas(H,fn)

vv = tpixR;     % theta power
H = plotsave(vv);
fn = [rat '_TPOWR.fig'];
saveas(H,fn)
vv = tpixL;
H = plotsave(vv);
fn = [rat '_TPOWL.fig'];
saveas(H,fn)
vv = tpixC;
H = plotsave(vv);
fn = [rat '_TPOWC.fig'];
saveas(H,fn)

vv = lgpixR;    % low gamma power
H = plotsave(vv);
fn = [rat '_GLPOWR.fig'];
saveas(H,fn)
vv = lgpixL;
H = plotsave(vv);
fn = [rat '_GLPOWL.fig'];
saveas(H,fn)
vv = lgpixC;
H = plotsave(vv);
fn = [rat '_GLPOWC.fig'];
saveas(H,fn)

vv = hgpixR;    % high gamma power
H = plotsave(vv);
fn = [rat '_GHPOWR.fig'];
saveas(H,fn)
vv = hgpixL;
H = plotsave(vv);
fn = [rat '_GHPOWL.fig'];
saveas(H,fn)
vv = hgpixC;
H = plotsave(vv);
fn = [rat '_GHPOWC.fig'];
saveas(H,fn)

% Save variables
save vars tpixR tpixL tpixC lgpixR lgpixL lgpixC hgpixR hgpixL hgpixC ...
    modix1glR modix2glR modix3glR modix4glR ...
    modix1glL modix2glL modix3glL modix4glL ...
    modix1ghR modix2ghR modix3ghR modix4ghR ...
    modix1ghL modix2ghL modix3ghL modix4ghL

% Spatial plot
SpR = figure;   % spatial plot
plot(trackx,tracky)
hold on
ap_xposR = linterp(0:length(trackx)-1,trackx,crossmod_timestampsR);
ap_yposR = linterp(0:length(tracky)-1,tracky,crossmod_timestampsR);
plot(ap_xposR,ap_yposR,'r.')
fn = [rat '_SpR.fig'];
saveas(SpR,fn)

SpL = figure;   % spatial plot
plot(trackx,tracky)
hold on
ap_xposL = linterp(0:length(trackx)-1,trackx,crossmod_timestampsL);
ap_yposL = linterp(0:length(tracky)-1,tracky,crossmod_timestampsL);
plot(ap_xposL,ap_yposL,'r.')
fn = [rat '_SpL.fig'];
saveas(SpL,fn)

[irhstR,irhstL,rhst2R,rhst2L,thst] = ...
    lczplace(ap_xposR,ap_yposR,ap_xposL,ap_yposL,trackx,tracky,0:length(trackx)-1);
SmR = figure;     % spatial map
pcolor(nanpad(irhstR,1))
shading flat;
axis off
colorbar
fn = [rat '_SmR.fig'];
saveas(SmR,fn)

SmL = figure;     % spatial map
pcolor(nanpad(irhstL,1))
shading flat;
axis off
colorbar
fn = [rat '_SmL.fig'];
saveas(SmL,fn)
    
close all
cd(mm)



% -------------------------------------------------------------------------
% POSITIONS
% -------------------------------------------------------------------------
function [x_pos y_pos] = poscorr(x_pos,y_pos)

% Leave out the outliers
dx = diff(x_pos);
fdx = find(abs(dx)>8&abs([dx(2:end) 0])>8&abs(dx-[dx(2:end) 0])>16);
x_pos(fdx+1) = NaN;
y_pos(fdx+1) = NaN;
dy = diff(y_pos);
fdy = find(abs(dy)>8&abs([dy(2:end) 0])>8&abs(dy-[dy(2:end) 0])>16);
x_pos(fdy+1) = NaN;
y_pos(fdy+1) = NaN;

% Leave out (0;0) points
inxs = x_pos > 0 & y_pos > 0;
x_pos(~inxs) = NaN;
y_pos(~inxs) = NaN;



% -------------------------------------------------------------------------
% RAYLEIGH'S TEST
% -------------------------------------------------------------------------
function [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL ...
    pglR pglL pghR pghL] = lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR, ...
    gammahL,trackx,tracky,WindowSize,Overlap)

[k1 k2] = size(thetaR);

winlen = WindowSize;   % window size
maxi = floor(k2/winlen);

% Gamma thresholds
TglR = mean(gammalR) + 2*std(gammalR);
TglL = mean(gammalL) + 2*std(gammalL);
TghR = mean(gammahR) + 2*std(gammahR);
TghL = mean(gammahL) + 2*std(gammahL);

% Rayleigh's test
ovlp = Overlap;
MItRglR = zeros(1,maxi*ovlp-ovlp+1);
MItRglL = zeros(1,maxi*ovlp-ovlp+1);
MItLglR = zeros(1,maxi*ovlp-ovlp+1);
MItLglL = zeros(1,maxi*ovlp-ovlp+1);
MItRghR = zeros(1,maxi*ovlp-ovlp+1);
MItRghL = zeros(1,maxi*ovlp-ovlp+1);
MItLghR = zeros(1,maxi*ovlp-ovlp+1);
MItLghL = zeros(1,maxi*ovlp-ovlp+1);
pglR = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pglL = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pghR = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pghL = zeros(1,maxi*ovlp-ovlp+1) * NaN;
for i = 1:maxi*ovlp-ovlp+1        % ABS LOOP
    inx1 = (i - 1) * winlen / ovlp + 1;  % Note: overlapping windows!
    inx1 = round(inx1);
    inx2 = inx1 + winlen - 1;
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if length(pbang) < 10
        MItRglR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRglR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRglR(i) = z;
        else
            MItRglR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if length(pbang) < 10
        MItRglL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRglL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRglL(i) = z;
        else
            MItRglL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if length(pbang) < 10
        MItLglR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLglR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLglR(i) = z;
        else
            MItLglR(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRglR',bang_tLglR');
        pglR(i) = pw(2);
        
%         if pw(2) <= 0.01 && abs(MItRglR(i)-MItLglR(i)) > 15
%             edges = -180:20:180;     % edges for phase histogram
%             cnts = (edges(1:end-1) + edges(2:end)) / 2;
%             figure
%             [nm xout] = histc(bang_tRglR*180/pi,edges);
%             nm = nm(1:end-1);
%             plot([cnts cnts+360],[nm nm],'r')
%             [nm xout] = histc(bang_tLglR*180/pi,edges);
%             nm = nm(1:end-1);
%             hold on
%             plot([cnts cnts+360],[nm nm])
%             x_lim = xlim;
%             y_lim = ylim;
%             xcoord = x_lim(1) + (x_lim(2)- x_lim(1)) * 0.2;
%             ycoord = y_lim(1) + (y_lim(2)- y_lim(1)) * 0.8;
%             tx = ['MItRglR (red): ' num2str(MItRglR(i)) ' MItLglR (blue): ' num2str(MItLglR(i))];
%             text(xcoord,ycoord,tx)
%         end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if length(pbang) < 10
        MItLglL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLglL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLglL(i) = z;
        else
            MItLglL(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRglL',bang_tLglL');
        pglL(i) = pw(2);
        
%         if pw(2) <= 0.01 && abs(MItRglL(i)-MItLglL(i)) > 15
%             edges = -180:20:180;     % edges for phase histogram
%             cnts = (edges(1:end-1) + edges(2:end)) / 2;
%             figure
%             [nm xout] = histc(bang_tLglL*180/pi,edges);
%             nm = nm(1:end-1);
%             plot([cnts cnts+360],[nm nm],'r')
%             [nm xout] = histc(bang_tRglL*180/pi,edges);
%             nm = nm(1:end-1);
%             hold on
%             plot([cnts cnts+360],[nm nm])
%             x_lim = xlim;
%             y_lim = ylim;
%             xcoord = x_lim(1) + (x_lim(2)- x_lim(1)) * 0.2;
%             ycoord = y_lim(1) + (y_lim(2)- y_lim(1)) * 0.8;
%             tx = ['MItLglL (red): ' num2str(MItLglL(i)) ' MItRglL (blue): ' num2str(MItRglL(i))];
%             text(xcoord,ycoord,tx)
%         end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if length(pbang) < 10
        MItRghR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRghR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRghR(i) = z;
        else
            MItRghR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if length(pbang) < 10
        MItRghL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRghL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRghL(i) = z;
        else
            MItRghL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if length(pbang) < 10
        MItLghR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLghR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLghR(i) = z;
        else
            MItLghR(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRghR',bang_tLghR');
        pghR(i) = pw(2);
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if length(pbang) < 10
        MItLghL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLghL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLghL(i) = z;
        else
            MItLghL(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRghL',bang_tLghL');
        pghL(i) = pw(2);
    end
    
end     % end of abs loop

% -------------------------------------------------------------------------
function [z p] = rayt(bang)

n = length(bang);
ftm = sum(exp(1).^(j*bang)) / n;    % first trigonometric moment
mrl = abs(ftm);     % mean resultant length
z = n * (mrl ^ 2);  % Rayleigh's Z statistic
p = exp(1) ^ (-1 * z) * (1 + (2 * z - z ^ 2) / ...
    (4 * n) - (24 * z - 132 * z ^ 2 + 76 * z ^ 3 - 9 * z ^ 4) / (288 * n ^ 2));



% -------------------------------------------------------------------------
% WAVELET
% -------------------------------------------------------------------------
function [wave,f] = eeg_wavelet(dat,sr)
%EEGWAVELET   Wavelet calculation.

% Prepare for wavelet transformation
variance = std(dat) ^ 2;
dat = (dat - mean(dat)) / sqrt(variance) ;
n = length(dat);
dt = 1 / sr;
pad = 1;
dj = 0.08;    
j1 = ceil((1/dj) * log2(n/2));
j1 = ceil(j1);
j = (0:j1);
s0 = 2 * dt; 
s = s0 .* 2 .^ (j * dj);
omega0 = 6;
c = 4 * pi / (omega0 + sqrt(2+omega0^2));
fperiod = c .* s;
f = 1 ./ fperiod;
lag1 = 0.72;
param = -1;
mif = 0.5;          %minimal intresting frequency
mis = find(f>mif);
mis = mis(end);     %maximal intristing scale
mother = 'Morlet';

% Wavelet transformation
[wave,period,scale,coi] = b_wavelet_new3(dat,dt,pad,dj,s0,j1,mother,param,mis);



% -------------------------------------------------------------------------
% NORMALIZATION
% -------------------------------------------------------------------------
function N = nrm1(pN)

N = pN - min(pN);
N = N / max(N);



% -------------------------------------------------------------------------
% INTERPOLATION
% -------------------------------------------------------------------------
function yi = llinterp(x,y,xi)
%LINTERP   1D linear interpolation.
%   YI = LINTERP(X,Y,XI) interpolates Y = f(XI), where f is given in (X,Y).
%
%   See also INTERP1Q.

% Interpolation
yi = zeros(1,length(xi));
for k = 1:length(xi)    % linear interpolation
    inx1 = find(x<xi(k),1,'last');
    if isempty(inx1) || inx1==length(x)
        continue
    end
    inx2 = inx1 + 1;
    yi(k) = y(inx1) + (y(inx2) - y(inx1)) * (xi(k)-x(inx1)) / (x(inx2) - x(inx1));
end



% -------------------------------------------------------------------------
% SEGMENTATION
% -------------------------------------------------------------------------
function sne = seglim(ip)

% Makes disjuct intervals from a set of points
drml = diff(ip);
fdr = find(drml>1);
lenfdr = length(fdr);
prepa = zeros(2,lenfdr+1);
prepa(1,1) = ip(1);
for t = 1:lenfdr
    prepa(2,t) = ip(fdr(t));
    prepa(1,t+1) = ip(fdr(t)+1);
end
prepa(2,end) = ip(end);
sne = prepa;



% -------------------------------------------------------------------------
% PLOT & SAVE
% -------------------------------------------------------------------------
function H = plotsave(vv)

H = figure;
hold on
plot(vv','b.')
bar(nanmean(vv),'FaceColor','none')



% -------------------------------------------------------------------------
% SPATIAL MAP
% -------------------------------------------------------------------------
function [irhst1,irhst2,rhst12,rhst22,thst] = ...
    lczplace(ap_xpos1,ap_ypos1,ap_xpos2,ap_ypos2,x_pos,y_pos,x_pos_ts)
%LCZPLACE   Place rate map.
%   [IRM1 IRM2 RM1 RM2 OM] = LCZPLACE(X1,Y1,X2,Y2,XPOS,YPOS,TS) returns
%   place rate maps (RM1 and RM2), interpolated place rate maps (IRM1 and
%   IRM2, for visualization) and occupancy map (OM) for two discriminated
%   units (positions: X1 and Y1; X2 and Y2). Input arguments XPOS and YPOS
%   are the rat position coordinates, TS should contain the corresponding
%   timestamps for the position values. Bins with less than 150 time or 3
%   visits are discarded.
%
%   In LCZPLACE, both the occupancy map and the rate map are smoothed by a
%   Gaussian kernel.
%
%   See also CZPLACE2.

% Input argumnet check
error(nargchk(7,7,nargin))

% Position vector correction
dx = diff(x_pos);       % leave out the outliers
fdx = find(abs(dx)>8&abs([dx(2:end) 0])>8&abs(dx-[dx(2:end) 0])>16);
x_pos(fdx+1) = [];
y_pos(fdx+1) = [];
x_pos_ts(fdx+1) = [];
dy = diff(y_pos);
fdy = find(abs(dy)>8&abs([dy(2:end) 0])>8&abs(dy-[dy(2:end) 0])>16);
x_pos(fdy+1) = [];
y_pos(fdy+1) = [];
x_pos_ts(fdy+1) = [];

inxs = x_pos > 0 & y_pos > 0;   % leave out (0;0) points
x_pos2 = x_pos(inxs);
y_pos2 = y_pos(inxs);
pos_ts = x_pos_ts(inxs);
% figure;plot(x_pos2,y_pos2,'.')

% Determine space bins
fminx = min(x_pos2);
fmaxx = max(x_pos2);
fminy = min(y_pos2);
fmaxy = max(y_pos2);

xedge = fminx-0.0001:8:fmaxx+8;      % spatial bins
yedge = fminy-0.0001:8:fmaxy+8;
xbins = length(xedge) - 1;
ybins = length(yedge) - 1;

% Determine the position of action potentials
hst1 = hist3([ap_xpos1' ap_ypos1'],'Edges',{xedge yedge})';     % spike number in space
hst1 = hst1(1:end-1,1:end-1);     % last bin corresponds to the upper edge value
hst2 = hist3([ap_xpos2' ap_ypos2'],'Edges',{xedge yedge})';     % spike number in space
hst2 = hst2(1:end-1,1:end-1);     % last bin corresponds to the upper edge value

% Calculate the time spent in each space bin
thst = zeros(size(hst1));        % time spent in each bin (occupancy map)
tvhst = zeros(size(hst1));       % number of visits
for xb = 1:xbins
    for yb = 1:ybins
        disp([num2str(xb) ' ' num2str(yb)])
        xedlow = xedge(xb);
        xedhigh = xedge(xb+1);
        xlin = valuecrossing(pos_ts,x_pos2,xedlow,'up');
        xhin = valuecrossing(pos_ts,x_pos2,xedhigh,'down');
        xlout = valuecrossing(pos_ts,x_pos2,xedlow,'down');
        xhout = valuecrossing(pos_ts,x_pos2,xedhigh,'up');
        xin = union(xlin,xhin);
        xout = union(xlout,xhout);
        if xout(1) < xin(1)
            xin = [pos_ts(1) xin];
        end
        if xin(end) > xout(end)
            xout = [xout pos_ts(end)];
        end
        if ~isequal(length(xin),length(xout))
            error('Technical error 119.')
        end
                
        yedlow = yedge(yb);
        yedhigh = yedge(yb+1);
        ylin = valuecrossing(pos_ts,y_pos2,yedlow,'up');
        yhin = valuecrossing(pos_ts,y_pos2,yedhigh,'down');
        ylout = valuecrossing(pos_ts,y_pos2,yedlow,'down');
        yhout = valuecrossing(pos_ts,y_pos2,yedhigh,'up');
        yin = union(ylin,yhin);
        yout = union(ylout,yhout);
        if yout(1) < yin(1)
            yin = [pos_ts(1) yin];
        end
        if yin(end) > yout(end)
            yout = [yout pos_ts(end)];
        end
        if ~isequal(length(yin),length(yout))
            error('Technical error 137.')
        end
        
        for k1 = 1:length(xin)
            cxin = xin(k1);
            cxout = xout(find(xout>cxin,1,'first'));
            logix = yin<cxout&yout>cxin;
            cyins = yin(logix);
            cyouts = yout(logix);
            for k2 = 1:length(cyins)
                cyin = cyins(k2);
                cyout = cyouts(k2);
                thst(yb,xb) = thst(yb,xb) + (min(cyout,cxout) - max(cyin,cxin));
                tvhst(yb,xb) = tvhst(yb,xb) + 1;
            end
        end
    end
end
gk = gausskernel([5 5],1);
thst = smooth2_nonnan(thst,gk); % smoothing
rhst1 = hst1 ./ thst;
rhst2 = hst2 ./ thst;

rhst12 = rhst1 .* zero2nan(double(thst>=150)) .* zero2nan(double(tvhst>=3));       % minimum 3 visits, 0.25 s spent in bin
rhst12 = smooth2_nonnan(rhst12,gk);
irhst1 = interp2_nonnan(rhst12,5);
rhst22 = rhst2 .* zero2nan(double(thst>=150)) .* zero2nan(double(tvhst>=3));       % minimum 3 visits, 0.25 s spent in bin
rhst22 = smooth2_nonnan(rhst22,gk);
irhst2 = interp2_nonnan(rhst22,5);