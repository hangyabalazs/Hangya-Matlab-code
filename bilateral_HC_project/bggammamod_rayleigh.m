function bggammamod_rayleigh(data,trials)
%BGGAMMAMOD_RAYLEIGH   Modulation of gamma power by theta phase.
%   BGGAMMAMOD_RAYLEIGH(DATA,TRIALS) compares the modulation of gamma power
%   by theta (4-12 Hz) phase in the ipsilateral and in the contralateral
%   hippocampus. Low gamma (30-40 Hz) and high gamma (80-120 Hz) are
%   calculated separately. Phase and amplitude values are generated by
%   Hilbert transformation. Coupling is detected by Rayleigh's test.
%
%   See also BGMI.

% Results directory
global DATAPATH
resdir = [DATAPATH 'Wheel\Gammamod_rayleigh3\'];
mm = pwd;
cd(resdir)

% Get trial EEG
lt = length(trials);
% lt = 1;
% error_WE = [];
% futureL_WE = [];
% futureR_WE = [];
HglRta = figure;
hold on
HglLta = figure;
hold on
HghRta = figure;
hold on
HghLta = figure;
hold on
HglRda = figure;
hold on
HglLda = figure;
hold on
HghRda = figure;
hold on
HghLda = figure;
hold on
dsglR = 1:20:18000;
dsglL = 1:20:18000;
dsghR = 1:20:18000;
dsghL = 1:20:18000;
aMIglR = [];
aMIglL = [];
aMIghR = [];
aMIghL = [];
aMIglR_err = [];
aMIglL_err = [];
aMIghR_err = [];
aMIghL_err = [];
aMIglR_fL = [];
aMIglL_fL = [];
aMIghR_fL = [];
aMIghL_fL = [];
aMIglR_fR = [];
aMIglL_fR = [];
aMIghR_fR = [];
aMIghL_fR = [];
for k = 1:lt
    k
    tS = round(trials{k}.tStart*4/5);  % indices are transformed to match new samp. rate
    tE = round(trials{k}.tEnd*4/5);
    time = linspace(tS,tE,length(trials{k}.Distance)*4/5+1);
    d1 = trials{k}.Distance(1);
    d2 = trials{k}.Distance(end-1);
    pd = linterp(linspace(tS,tE,length(trials{k}.Distance)),...
        trials{k}.Distance,time(2:end-1));
    distance = [d1 pd d2];   % distance from the start point
    eegR = data(10,tS:tE);   % shank: 4 or 10
    eegL = data(4,tS:tE);
    
% Filter
    sr = 1000;
    nqf = sr / 2;
    flt = fir1(1024,[4 12]/nqf,'band');      % bandpass filtering: theta frequency band bounderies: 8-10 Hz
    feeg_thetaR = filtfilt(flt,1,eegR);
    feeg_thetaR = (feeg_thetaR - mean(feeg_thetaR)) / std(feeg_thetaR);
    feeg_thetaL = filtfilt(flt,1,eegL);
    feeg_thetaL = (feeg_thetaL - mean(feeg_thetaL)) / std(feeg_thetaL);
    hilb_thphaseR = angle(hilbert(feeg_thetaR));
    hilb_thphaseL = angle(hilbert(feeg_thetaL));
    flt = fir1(1024,[30 40]/nqf,'band');      % bandpass filtering: low gamma frequency band bounderies: 30-40 Hz
    feeg_lowR = filtfilt(flt,1,eegR);
    feeg_lowR = (feeg_lowR - mean(feeg_lowR)) / std(feeg_lowR);
    feeg_lowL = filtfilt(flt,1,eegL);
    feeg_lowL = (feeg_lowL - mean(feeg_lowL)) / std(feeg_lowL);
    hilb_glabsR = abs(hilbert(feeg_lowR));
    hilb_glabsL = abs(hilbert(feeg_lowL));
    flt = fir1(1024,[80 120]/nqf,'band');      % bandpass filtering: high gamma frequency band bounderies: 80-120 Hz
    feeg_highR = filtfilt(flt,1,eegR);
    feeg_highR = (feeg_highR - mean(feeg_highR)) / std(feeg_highR);
    feeg_highL = filtfilt(flt,1,eegL);
    feeg_highL = (feeg_highL - mean(feeg_highL)) / std(feeg_highL);
    hilb_ghabsR = abs(hilbert(feeg_highR));
    hilb_ghabsL = abs(hilbert(feeg_highL));
    
% Wavelet
%     [wavea_absR wavea_phaseR f spf] = eeg_wavelet(eegR); % eeg sampled on 1000 Hz
%     [wavea_absL wavea_phaseL f spf] = eeg_wavelet(eegL);
%     H1 = figure;
%     imagesc(wavea_abs)
%     b_rescaleaxis('Y',f)
    
% Modulation vs. distance
    thetaR = nrm1(hilb_thphaseR); % normalization
    thetaL = nrm1(hilb_thphaseL);
    gammalR = nrm1(hilb_glabsR);
    gammalL = nrm1(hilb_glabsL);
    gammahR = nrm1(hilb_ghabsR);
    gammahL = nrm1(hilb_ghabsL);

% Rayleigh-test
    [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL] = ...
        lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR,gammahL,1000,10);
% Plot
    tm = linspace(0,tE-tS,length(MItRglR));
    tm2 = linspace(tS,tE,length(MItRglR));
    dst = linterp(linspace(tS,tE,length(trials{k}.Distance)),...
        trials{k}.Distance,tm2(2:end-1));
    dst = [d1 dst d2];
    HglRt = figure;
    plot(tm,MItLglR-MItRglR,'b.-')
    HglLt = figure;
    plot(tm,MItRglL-MItLglL,'b.-')
    HghRt = figure;
    plot(tm,MItLghR-MItRghR,'b.-')
    HghLt = figure;
    plot(tm,MItRghL-MItLghL,'b.-')
    
    HglRd = figure;
    plot(dst,MItLglR-MItRglR,'b.-')
    HglLd = figure;
    plot(dst,MItRglL-MItLglL,'b.-')
    HghRd = figure;
    plot(dst,MItLghR-MItRghR,'b.-')
    HghLd = figure;
    plot(dst,MItRghL-MItLghL,'b.-')
    
    figure(HglRta);
    plot(tm,MItLglR-MItRglR,'b.-')
    figure(HglLta);
    plot(tm,MItRglL-MItLglL,'b.-')
    figure(HghRta);
    plot(tm,MItLghR-MItRghR,'b.-')
    figure(HghLta);
    plot(tm,MItRghL-MItLghL,'b.-')
    
    figure(HglRda);
    plot(dst,MItLglR-MItRglR,'b.-')
    figure(HglLda);
    plot(dst,MItRglL-MItLglL,'b.-')
    figure(HghRda);
    plot(dst,MItLghR-MItRghR,'b.-')
    figure(HghLda);
    plot(dst,MItRghL-MItLghL,'b.-')
    
    aMIglR(end+1,:) = llinterp(dst,MItLglR-MItRglR,dsglR);
    aMIglL(end+1,:) = llinterp(dst,MItLglL-MItRglL,dsglL);
    aMIghR(end+1,:) = llinterp(dst,MItLghR-MItRghR,dsghR);
    aMIghL(end+1,:) = llinterp(dst,MItLghL-MItRghL,dsghL);
    
% Save
    if trials{k}.errorTrial
        cd error

        aMIglR_err(end+1,:) = llinterp(dst,MItLglR-MItRglR,dsglR);
        aMIglL_err(end+1,:) = llinterp(dst,MItLglL-MItRglL,dsglL);
        aMIghR_err(end+1,:) = llinterp(dst,MItLghR-MItRghR,dsghR);
        aMIghL_err(end+1,:) = llinterp(dst,MItLghL-MItRghL,dsghL);
    else
        if isequal(trials{k}.futureLR,'L')
            cd futureL
            
            aMIglR_fL(end+1,:) = llinterp(dst,MItLglR-MItRglR,dsglR);
            aMIglL_fL(end+1,:) = llinterp(dst,MItLglL-MItRglL,dsglL);
            aMIghR_fL(end+1,:) = llinterp(dst,MItLghR-MItRghR,dsghR);
            aMIghL_fL(end+1,:) = llinterp(dst,MItLghL-MItRghL,dsghL);
        elseif isequal(trials{k}.futureLR,'R')
            cd futureR
            
            aMIglR_fR(end+1,:) = llinterp(dst,MItLglR-MItRglR,dsglR);
            aMIglL_fR(end+1,:) = llinterp(dst,MItLglL-MItRglL,dsglL);
            aMIghR_fR(end+1,:) = llinterp(dst,MItLghR-MItRghR,dsghR);
            aMIghL_fR(end+1,:) = llinterp(dst,MItLghL-MItRghL,dsghL);
        else
            keyboard
        end
    end
    fn = ['g01_m13_t' num2str(k) '_MIglRt.fig'];
    saveas(HglRt,fn)
    fn = ['g01_m13_t' num2str(k) '_MIglLt.fig'];
    saveas(HglLt,fn)
    fn = ['g01_m13_t' num2str(k) '_MIghRt.fig'];
    saveas(HghRt,fn)
    fn = ['g01_m13_t' num2str(k) '_MIghLt.fig'];
    saveas(HghLt,fn)
    fn = ['g01_m13_t' num2str(k) '_MIglRd.fig'];
    saveas(HglRd,fn)
    fn = ['g01_m13_t' num2str(k) '_MIglLd.fig'];
    saveas(HglLd,fn)
    fn = ['g01_m13_t' num2str(k) '_MIghRd.fig'];
    saveas(HghRd,fn)
    fn = ['g01_m13_t' num2str(k) '_MIghLd.fig'];
    saveas(HghLd,fn)
    
    cd ..
    close(HglRt,HglLt,HghRt,HghLt,HglRd,HglLd,HghRd,HghLd)
end
save vars aMIglR aMIglL aMIghR aMIghL aMIglR_err aMIglL_err aMIghR_err aMIghL_err...
    aMIglR_fL aMIglL_fL aMIghR_fL aMIghL_fL aMIglR_fR aMIglL_fR aMIghR_fR aMIghL_fR
cd(mm)



% -------------------------------------------------------------------------
% RAYLEIGH'S TEST
% -------------------------------------------------------------------------
function [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL] = ...
    lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR,gammahL,WindowSize,Overlap)

[k1 k2] = size(thetaR);

winlen = WindowSize;   % window size
maxi = floor(k2/winlen);

% Gamma thresholds
TglR = mean(gammalR) + 2*std(gammalR);
TglL = mean(gammalL) + 2*std(gammalL);
TghR = mean(gammahR) + 2*std(gammahR);
TghL = mean(gammahL) + 2*std(gammahL);

% Rayleigh's test
ovlp = Overlap;
MItRglR = zeros(1,maxi*ovlp-ovlp+1);
MItRglL = zeros(1,maxi*ovlp-ovlp+1);
MItLglR = zeros(1,maxi*ovlp-ovlp+1);
MItLglL = zeros(1,maxi*ovlp-ovlp+1);
MItRghR = zeros(1,maxi*ovlp-ovlp+1);
MItRghL = zeros(1,maxi*ovlp-ovlp+1);
MItLghR = zeros(1,maxi*ovlp-ovlp+1);
MItLghL = zeros(1,maxi*ovlp-ovlp+1);
for i = 1:maxi*ovlp-ovlp+1        % ABS LOOP
    inx1 = (i - 1) * winlen / ovlp + 1;  % Note: overlapping windows!
    inx1 = round(inx1);
    inx2 = inx1 + winlen - 1;
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if isempty(pbang)
        MItRglR(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItRglR(i) = z;
        else
           MItRglR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if isempty(pbang)
        MItRglL(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItRglL(i) = z;
        else
            MItRglL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if isempty(pbang)
        MItLglR(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItLglR(i) = z;
        else
            MItLglR(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if isempty(pbang)
        MItLglL(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItLglL(i) = z;
        else
            MItLglL(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if isempty(pbang)
        MItRghR(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItRghR(i) = z;
        else
            MItRghR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if isempty(pbang)
        MItRghL(i) = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItRghL(i) = z;
        else
            MItRghL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if isempty(pbang)
        MItLghR = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItLghR(i) = z;
        else
            MItLghR(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if isempty(pbang)
        MItLghL = NaN;
    else
        bang = yj1(pbang);
        [z p] = rayt(bang);
        if p < 0.001
            MItLghL(i) = z;
        else
            MItLghL(i) = NaN;
        end
    end
end     % end of abs loop

% -------------------------------------------------------------------------
function [z p] = rayt(bang)

n = length(bang);
ftm = sum(exp(1).^(j*bang)) / n;    % first trigonometric moment
mrl = abs(ftm);     % mean resultant length
z = n * (mrl ^ 2);  % Rayleigh's Z statistic
p = exp(1) ^ (-1 * z) * (1 + (2 * z - z ^ 2) / ...
    (4 * n) - (24 * z - 132 * z ^ 2 + 76 * z ^ 3 - 9 * z ^ 4) / (288 * n ^ 2));

% -------------------------------------------------------------------------
% NORMALIZATION
% -------------------------------------------------------------------------
function N = nrm1(pN)

N = pN - min(pN);
N = N / max(N);



% -------------------------------------------------------------------------
% INTERPOLATION
% -------------------------------------------------------------------------
function yi = llinterp(x,y,xi)
%LINTERP   1D linear interpolation.
%   YI = LINTERP(X,Y,XI) interpolates Y = f(XI), where f is given in (X,Y).
%
%   See also INTERP1Q.

% Interpolation
yi = zeros(1,length(xi));
for k = 1:length(xi)    % linear interpolation
    inx1 = find(x<xi(k),1,'last');
    if isempty(inx1) || inx1==length(x)
        continue
    end
    inx2 = inx1 + 1;
    yi(k) = y(inx1) + (y(inx2) - y(inx1)) * (xi(k)-x(inx1)) / (x(inx2) - x(inx1));
end