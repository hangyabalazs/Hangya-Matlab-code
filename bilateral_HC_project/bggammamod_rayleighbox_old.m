function bggammamod_rayleighbox(data,Laps)
%BGGAMMAMOD_RAYLEIGHBOX   Modulation of gamma power by theta phase.
%   BGGAMMAMOD_RAYLEIGHBOX(DATA,LAPS) compares the modulation of gamma power
%   by theta (4-12 Hz) phase in the ipsilateral and in the contralateral
%   hippocampus. Low gamma (30-40 Hz) and high gamma (80-120 Hz) are
%   calculated separately. Phase and amplitude values are generated by
%   Hilbert transformation. Coupling is detected by Rayleigh's test.
%
%   BGGAMMAMOD_RAYLEIGHBOX calculates group data for crossmodulation
%   values. Wavelet power and crosswavelet power in the relevant frequency
%   bands are also analyzed.
%
%   See also BGGAMMAMOD_RAYLEIGH2.

% Results directory
global DATAPATH
resdir = [DATAPATH 'Wheel2\g01_m13\Gammamod_rayleighbox2\4_10_old\'];
rat = 'g01_m13';
mm = pwd;
cd(resdir)

% Laps
lap_start = find(Laps.StartLaps)';
lap_start = find(diff(Laps.MazeSection==1)==1)';
lap_end = [lap_start(2:end)-1 size(Laps.TrialType,1)];
lap_mazesection = round(resample(Laps.MazeSection,4,5));
lap_center = round((lap_start+lap_end)/2);
lap_type = Laps.TrialType(lap_center);
lap_behav = Laps.BehavType(lap_center);
lap_start = round(lap_start*4/5);  % indices are transformed to match new samp. rate
lap_end = [lap_start(2:end)-1 size(data,2)];
lap_center = round((lap_start+lap_end)/2);
lt = length(lap_start);
% lt = 1;
% error_WE = [];
% futureL_WE = [];
% futureR_WE = [];

% Main
modix1glR = zeros(lt,10) * NaN;     % initialization
modix2glR = zeros(lt,10) * NaN;
modix3glR = zeros(lt,10) * NaN;
modix4glR = zeros(lt,10) * NaN;
modix1glL = zeros(lt,10) * NaN;
modix2glL = zeros(lt,10) * NaN;
modix3glL = zeros(lt,10) * NaN;
modix4glL = zeros(lt,10) * NaN;
modix1ghR = zeros(lt,10) * NaN;
modix2ghR = zeros(lt,10) * NaN;
modix3ghR = zeros(lt,10) * NaN;
modix4ghR = zeros(lt,10) * NaN;
modix1ghL = zeros(lt,10) * NaN;
modix2ghL = zeros(lt,10) * NaN;
modix3ghL = zeros(lt,10) * NaN;
modix4ghL = zeros(lt,10) * NaN;
tpixR = zeros(lt,10) * NaN;
lgpixR = zeros(lt,10) * NaN;
hgpixR = zeros(lt,10) * NaN;
tpixL = zeros(lt,10) * NaN;
lgpixL = zeros(lt,10) * NaN;
hgpixL = zeros(lt,10) * NaN;
tpixC = zeros(lt,10) * NaN;
lgpixC = zeros(lt,10) * NaN;
hgpixC = zeros(lt,10) * NaN;
for k = 1:lt   % 'lap' cycle
    k
    if ~isequal(lap_behav(k),1) || isequal(lap_type(k),0)
        continue
    end
    tS = lap_start(k);      % get trial EEG
    tE = lap_end(k);
    eegR = data(10,tS:tE);   % shank: 10
    eegL = data(4,tS:tE);   % shank: 4
    maze_section = lap_mazesection(tS:tE);
    
% Filter and Hilbert-transform
    sr = 1000;
    nqf = sr / 2;
    flt = fir1(1024,[4 12]/nqf,'band');      % bandpass filtering: theta frequency band bounderies: 8-10 Hz
    if length(eegR) < 3 * 1024
        continue
    end
    feeg_thetaR = filtfilt(flt,1,eegR);
    feeg_thetaR = (feeg_thetaR - mean(feeg_thetaR)) / std(feeg_thetaR);
    feeg_thetaL = filtfilt(flt,1,eegL);
    feeg_thetaL = (feeg_thetaL - mean(feeg_thetaL)) / std(feeg_thetaL);
    hilb_thphaseR = angle(hilbert(feeg_thetaR));    % Hilbert-transform
    hilb_thphaseL = angle(hilbert(feeg_thetaL));
    flt = fir1(1024,[30 40]/nqf,'band');      % bandpass filtering: low gamma frequency band bounderies: 30-40 Hz
    feeg_lowR = filtfilt(flt,1,eegR);
    feeg_lowR = (feeg_lowR - mean(feeg_lowR)) / std(feeg_lowR);
    feeg_lowL = filtfilt(flt,1,eegL);
    feeg_lowL = (feeg_lowL - mean(feeg_lowL)) / std(feeg_lowL);
    hilb_glabsR = abs(hilbert(feeg_lowR));
    hilb_glabsL = abs(hilbert(feeg_lowL));
    flt = fir1(1024,[80 120]/nqf,'band');      % bandpass filtering: high gamma frequency band bounderies: 80-120 Hz
    feeg_highR = filtfilt(flt,1,eegR);
    feeg_highR = (feeg_highR - mean(feeg_highR)) / std(feeg_highR);
    feeg_highL = filtfilt(flt,1,eegL);
    feeg_highL = (feeg_highL - mean(feeg_highL)) / std(feeg_highL);
    hilb_ghabsR = abs(hilbert(feeg_highR));
    hilb_ghabsL = abs(hilbert(feeg_highL));
    
% Wavelet
    [waveR f] = eeg_wavelet(eegR,sr);   % EEG sampled on 1000 Hz
    [waveL f] = eeg_wavelet(eegL,sr);
    wave_cross = waveR .* conj(waveL);
    waveaR = abs(waveR) .^ 2;
    waveaL = abs(waveL) .^ 2;
    wavea_cross = abs(wave_cross) .^ 2;     % crosswavelet
    clear waveR waveL wave_cross
    pwind1t = find(f>4,1,'last');    % frequency band bounderies
    pwind2t = find(f<12,1,'first');
    pwind1lg = find(f>30,1,'last');
    pwind2lg = find(f<40,1,'first');
    pwind1hg = find(f>80,1,'last');
    pwind2hg = find(f<120,1,'first');
    tpowerR = mean(waveaR(pwind2t:pwind1t,:));      % wavelet power
    tpowerL = mean(waveaL(pwind2t:pwind1t,:));
    tpowerC = mean(wavea_cross(pwind2t:pwind1t,:));     % crosswavelet power
    lgpowerR = mean(waveaR(pwind2lg:pwind1lg,:));
    lgpowerL = mean(waveaL(pwind2lg:pwind1lg,:));
    lgpowerC = mean(wavea_cross(pwind2lg:pwind1lg,:));
    hgpowerR = mean(waveaR(pwind2hg:pwind1hg,:));
    hgpowerL = mean(waveaL(pwind2hg:pwind1hg,:));
    hgpowerC = mean(wavea_cross(pwind2hg:pwind1hg,:));
            
% Normalization
    thetaR = nrm1(hilb_thphaseR); % normalization
    thetaL = nrm1(hilb_thphaseL);
    gammalR = nrm1(hilb_glabsR);
    gammalL = nrm1(hilb_glabsL);
    gammahR = nrm1(hilb_ghabsR);
    gammahL = nrm1(hilb_ghabsL);

% Rayleigh-test
    [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL pglR pglL pghR pghL] = ...
        lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR,gammahL,1000,10);
    
% Wavelet images
    tm = linspace(0,tE-tS,length(MItRglR));
    tmm = linspace(0,tE-tS,length(maze_section));
    HR = figure;        % save wavelet images
    imagesc(waveaR)
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItRglR - MItLglR;
    plot(tm,60-5*cfdf,'c.-')
    hold on
    cfdf(isnan(pglL)|pglL>0.01) = NaN;
    plot(tm,60-5*cfdf,'y.-')
    b_rescaleaxis('Y',f)
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
    b_zoomset_for_wavelet
    HL = figure;
    imagesc(waveaL)
    b_rescaleaxis('Y',f(f>0.5))
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
%     setappdata(gca,'scalex',tmm)
%     setappdata(gca,'scaley',f(f>0.5))
%     b_zoomset_for_wavelet
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItRglL - MItLglL;
    plot(tm,60-5*cfdf,'c.-')
    hold on
    cfdf(isnan(pglL)|pglL>0.01) = NaN;
    plot(tm,60-5*cfdf,'y.-')
    HC = figure;
    imagesc(wavea_cross)
    hold on
    plot(tmm,maze_section,'Color','white')
    plot(tmm(maze_section==7|maze_section==8),...
        maze_section(maze_section==7|maze_section==8),'Color','red')
    cfdf = MItRglR - MItLglR;
    plot(tm,60-5*cfdf,'c.-')
    hold on
    cfdf(isnan(pglL)|pglL>0.01) = NaN;
    plot(tm,60-5*cfdf,'y.-')
    b_rescaleaxis('Y',f)
    b_rescaleaxis('X',(1:size(waveaR,2))/sr)
    b_zoomset_for_wavelet
    cd('wavelet')
    fn = [rat '_t' num2str(k) '_waveR.jpg'];
    saveas(HR,fn)
    fn = [rat '_t' num2str(k) '_waveL.jpg'];
    saveas(HL,fn)
    fn = [rat '_t' num2str(k) '_waveC.jpg'];
    saveas(HC,fn)
    close(HR,HL,HC)
    cd ..
    
% Calculate cross-modulation and wavelet power for maze segments
    for mseg = 1:10
        inx = find(maze_section==mseg);     % wavelet and crosswavelet power for maze segments
        tpixR(k,mseg) = nanmean(tpowerR(inx));
        lgpixR(k,mseg) = nanmean(lgpowerR(inx));
        hgpixR(k,mseg) = nanmean(hgpowerR(inx));
        tpixL(k,mseg) = nanmean(tpowerL(inx));
        lgpixL(k,mseg) = nanmean(lgpowerL(inx));
        hgpixL(k,mseg) = nanmean(hgpowerL(inx));
        tpixC(k,mseg) = nanmean(tpowerC(inx));
        lgpixC(k,mseg) = nanmean(lgpowerC(inx));
        hgpixC(k,mseg) = nanmean(hgpowerC(inx));
        
        cfdf = MItLglR - MItRglR;   % cross-modulation for maze segments; low gamma, right
        cfdf2 = cfdf;
        cfdf2(isnan(pglR)|pglR>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1glR(k,mseg) = nanmean(mcf);       % all values
        modix2glR(k,mseg) = nanmean(mcf2);      % > 0 values
        modix3glR(k,mseg) = nanmean(mcf3);      % significant
        modix4glR(k,mseg) = nanmean(mcf4);      % significant and > 0
        
        cfdf = MItLglL - MItRglL;       % low gamma, left
        cfdf2 = cfdf;
        cfdf2(isnan(pglL)|pglL>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1glL(k,mseg) = nanmean(mcf);
        modix2glL(k,mseg) = nanmean(mcf2);
        modix3glL(k,mseg) = nanmean(mcf3);
        modix4glL(k,mseg) = nanmean(mcf4);
        
        cfdf = MItLghR - MItRghR;       % high gamma, right
        cfdf2 = cfdf;
        cfdf2(isnan(pghR)|pghR>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1ghR(k,mseg) = nanmean(mcf);
        modix2ghR(k,mseg) = nanmean(mcf2);
        modix3ghR(k,mseg) = nanmean(mcf3);
        modix4ghR(k,mseg) = nanmean(mcf4);
        
        cfdf = MItLghL - MItRghL;       % high gamma, left
        cfdf2 = cfdf;
        cfdf2(isnan(pghL)|pghL>0.01) = NaN;
        inx = find(maze_section==mseg);
        if isempty(inx)
            continue
        end
        sne = seglim(inx);
        inx2 = [];
        for inc = 1:size(sne,2)
            pinx = find(tm>tmm(sne(1,inc))&tm<tmm(sne(2,inc)));
            inx2 = [inx2 pinx];
        end
        mcf = cfdf(inx2);
        mcf2 = mcf(mcf>0);
        mcf3 = cfdf2(inx2);
        mcf4 = mcf3(mcf3>0);
        modix1ghL(k,mseg) = nanmean(mcf);
        modix2ghL(k,mseg) = nanmean(mcf2);
        modix3ghL(k,mseg) = nanmean(mcf3);
        modix4ghL(k,mseg) = nanmean(mcf4);
    end
    
%     switch lap_type(k)
%         case {3,4}
%             cd error
% 
%         case 2
%             cd futureL
% 
%         case 1
%             cd futureR
% 
%         otherwise
%             keyboard
%     end
%     cd ..
end

% Plot and save
vv = modix1glR;     % cross-modulation; low gamma, right
H = plotsave(vv);
fn = [rat '_XMOD1glR.fig'];
saveas(H,fn)
vv = modix2glR;
H = plotsave(vv);
fn = [rat '_XMOD2glR.fig'];
saveas(H,fn)
vv = modix3glR;
H = plotsave(vv);
fn = [rat '_XMOD3glR.fig'];
saveas(H,fn)
vv = modix4glR;
H = plotsave(vv);
fn = [rat '_XMOD4glR.fig'];
saveas(H,fn)

vv = modix1glL;     % low gamma, left
H = plotsave(vv);
fn = [rat '_XMOD1glL.fig'];
saveas(H,fn)
vv = modix2glL;
H = plotsave(vv);
fn = [rat '_XMOD2glL.fig'];
saveas(H,fn)
vv = modix3glL;
H = plotsave(vv);
fn = [rat '_XMOD3glL.fig'];
saveas(H,fn)
vv = modix4glL;
H = plotsave(vv);
fn = [rat '_XMOD4glL.fig'];
saveas(H,fn)

vv = modix1ghR;     % high gamma, right
H = plotsave(vv);
fn = [rat '_XMOD1ghR.fig'];
saveas(H,fn)
vv = modix2ghR;
H = plotsave(vv);
fn = [rat '_XMOD2ghR.fig'];
saveas(H,fn)
vv = modix3ghR;
H = plotsave(vv);
fn = [rat '_XMOD3ghR.fig'];
saveas(H,fn)
vv = modix4ghR;
H = plotsave(vv);
fn = [rat '_XMOD4ghR.fig'];
saveas(H,fn)

vv = modix1ghL;     % high gamma, left
H = plotsave(vv);
fn = [rat '_XMOD1ghL.fig'];
saveas(H,fn)
vv = modix2ghL;
H = plotsave(vv);
fn = [rat '_XMOD2ghL.fig'];
saveas(H,fn)
vv = modix3ghL;
H = plotsave(vv);
fn = [rat '_XMOD3ghL.fig'];
saveas(H,fn)
vv = modix4ghL;
H = plotsave(vv);
fn = [rat '_XMOD4ghL.fig'];
saveas(H,fn)

vv = tpixR;     % theta power
H = plotsave(vv);
fn = [rat '_TPOWR.fig'];
saveas(H,fn)
vv = tpixL;
H = plotsave(vv);
fn = [rat '_TPOWL.fig'];
saveas(H,fn)
vv = tpixC;
H = plotsave(vv);
fn = [rat '_TPOWC.fig'];
saveas(H,fn)

vv = lgpixR;    % low gamma power
H = plotsave(vv);
fn = [rat '_GLPOWR.fig'];
saveas(H,fn)
vv = lgpixL;
H = plotsave(vv);
fn = [rat '_GLPOWL.fig'];
saveas(H,fn)
vv = lgpixC;
H = plotsave(vv);
fn = [rat '_GLPOWC.fig'];
saveas(H,fn)

vv = hgpixR;    % high gamma power
H = plotsave(vv);
fn = [rat '_GHPOWR.fig'];
saveas(H,fn)
vv = hgpixL;
H = plotsave(vv);
fn = [rat '_GHPOWL.fig'];
saveas(H,fn)
vv = hgpixC;
H = plotsave(vv);
fn = [rat '_GHPOWC.fig'];
saveas(H,fn)

% Save variables
save vars tpixR tpixL tpixC lgpixR lgpixL lgpixC hgpixR hgpixL hgpixC ...
    modix1glR modix2glR modix3glR modix4glR ...
    modix1glL modix2glL modix3glL modix4glL ...
    modix1ghR modix2ghR modix3ghR modix4ghR ...
    modix1ghL modix2ghL modix3ghL modix4ghL
close all
cd(mm)



% -------------------------------------------------------------------------
% RAYLEIGH'S TEST
% -------------------------------------------------------------------------
function [MItRglR MItRglL MItLglR MItLglL MItRghR MItRghL MItLghR MItLghL ...
    pglR pglL pghR pghL] = ...
    lrayleigh(thetaR,thetaL,gammalR,gammalL,gammahR,gammahL,WindowSize,Overlap)

[k1 k2] = size(thetaR);

winlen = WindowSize;   % window size
maxi = floor(k2/winlen);

% Gamma thresholds
TglR = mean(gammalR) + 2*std(gammalR);
TglL = mean(gammalL) + 2*std(gammalL);
TghR = mean(gammahR) + 2*std(gammahR);
TghL = mean(gammahL) + 2*std(gammahL);

% Rayleigh's test
ovlp = Overlap;
MItRglR = zeros(1,maxi*ovlp-ovlp+1);
MItRglL = zeros(1,maxi*ovlp-ovlp+1);
MItLglR = zeros(1,maxi*ovlp-ovlp+1);
MItLglL = zeros(1,maxi*ovlp-ovlp+1);
MItRghR = zeros(1,maxi*ovlp-ovlp+1);
MItRghL = zeros(1,maxi*ovlp-ovlp+1);
MItLghR = zeros(1,maxi*ovlp-ovlp+1);
MItLghL = zeros(1,maxi*ovlp-ovlp+1);
pglR = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pglL = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pghR = zeros(1,maxi*ovlp-ovlp+1) * NaN;
pghL = zeros(1,maxi*ovlp-ovlp+1) * NaN;
for i = 1:maxi*ovlp-ovlp+1        % ABS LOOP
    inx1 = (i - 1) * winlen / ovlp + 1;  % Note: overlapping windows!
    inx1 = round(inx1);
    inx2 = inx1 + winlen - 1;
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if length(pbang) < 10
        MItRglR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRglR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRglR(i) = z;
        else
           MItRglR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if length(pbang) < 10
        MItRglL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRglL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRglL(i) = z;
        else
            MItRglL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalR(inx1:inx2);
    pbang = find(yj2>TglR);
    if length(pbang) < 10
        MItLglR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLglR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLglR(i) = z;
        else
            MItLglR(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRglR',bang_tLglR');
        pglR(i) = pw(2);
        
%         if pw(2) <= 0.01 && abs(MItRglR(i)-MItLglR(i)) > 15
%             figure
%             [nm xout] = hist(bang_tRglR,18);
%             plot(xout,nm,'r')
%             [nm xout] = hist(bang_tLglR,18);
%             hold on
%             plot(xout,nm)
%             x_lim = xlim;
%             y_lim = ylim;
%             xcoord = x_lim(1) + (x_lim(2)- x_lim(1)) * 0.2;
%             ycoord = y_lim(1) + (y_lim(2)- y_lim(1)) * 0.8;
%             tx = ['MItRglR (red): ' num2str(MItRglR(i)) ' MItLglR (blue): ' num2str(MItLglR(i))];
%             text(xcoord,ycoord,tx)
%         end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammalL(inx1:inx2);
    pbang = find(yj2>TglL);
    if length(pbang) < 10
        MItLglL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLglL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLglL(i) = z;
        else
            MItLglL(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRglL',bang_tLglL');
        pglL(i) = pw(2);
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if length(pbang) < 10
        MItRghR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRghR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRghR(i) = z;
        else
            MItRghR(i) = NaN;
        end
    end
    
    yj1 = thetaR(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if length(pbang) < 10
        MItRghL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tRghL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItRghL(i) = z;
        else
            MItRghL(i) = NaN;
        end
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahR(inx1:inx2);
    pbang = find(yj2>TghR);
    if length(pbang) < 10
        MItLghR(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLghR = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLghR(i) = z;
        else
            MItLghR(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRghR',bang_tLghR');
        pghR(i) = pw(2);
    end
    
    yj1 = thetaL(inx1:inx2);
    yj2 = gammahL(inx1:inx2);
    pbang = find(yj2>TghL);
    if length(pbang) < 10
        MItLghL(i) = NaN;
    else
        bang = yj1(pbang);
        bang_tLghL = bang;
        [z p] = rayt(bang);
        if p < 0.001
            MItLghL(i) = z;
        else
            MItLghL(i) = NaN;
        end
        [u2 pw] = b_watsontwo(bang_tRghL',bang_tLghL');
        pghL(i) = pw(2);
    end
    
end     % end of abs loop

% -------------------------------------------------------------------------
function [z p] = rayt(bang)

n = length(bang);
ftm = sum(exp(1).^(j*bang)) / n;    % first trigonometric moment
mrl = abs(ftm);     % mean resultant length
z = n * (mrl ^ 2);  % Rayleigh's Z statistic
p = exp(1) ^ (-1 * z) * (1 + (2 * z - z ^ 2) / ...
    (4 * n) - (24 * z - 132 * z ^ 2 + 76 * z ^ 3 - 9 * z ^ 4) / (288 * n ^ 2));



% -------------------------------------------------------------------------
% WAVELET
% -------------------------------------------------------------------------
function [wave,f] = eeg_wavelet(dat,sr)
%EEGWAVELET   Wavelet calculation.

% Prepare for wavelet transformation
variance = std(dat) ^ 2;
dat = (dat - mean(dat)) / sqrt(variance) ;
n = length(dat);
dt = 1 / sr;
pad = 1;
dj = 0.08;    
j1 = ceil((1/dj) * log2(n/2));
j1 = ceil(j1);
j = (0:j1);
s0 = 2 * dt; 
s = s0 .* 2 .^ (j * dj);
omega0 = 6;
c = 4 * pi / (omega0 + sqrt(2+omega0^2));
fperiod = c .* s;
f = 1 ./ fperiod;
lag1 = 0.72;
param = -1;
mif = 0.5;          %minimal intresting frequency
mis = find(f>mif);
mis = mis(end);     %maximal intristing scale
mother = 'Morlet';

% Wavelet transformation
[wave,period,scale,coi] = b_wavelet_new3(dat,dt,pad,dj,s0,j1,mother,param,mis);



% -------------------------------------------------------------------------
% NORMALIZATION
% -------------------------------------------------------------------------
function N = nrm1(pN)

N = pN - min(pN);
N = N / max(N);



% -------------------------------------------------------------------------
% INTERPOLATION
% -------------------------------------------------------------------------
function yi = llinterp(x,y,xi)
%LINTERP   1D linear interpolation.
%   YI = LINTERP(X,Y,XI) interpolates Y = f(XI), where f is given in (X,Y).
%
%   See also INTERP1Q.

% Interpolation
yi = zeros(1,length(xi));
for k = 1:length(xi)    % linear interpolation
    inx1 = find(x<xi(k),1,'last');
    if isempty(inx1) || inx1==length(x)
        continue
    end
    inx2 = inx1 + 1;
    yi(k) = y(inx1) + (y(inx2) - y(inx1)) * (xi(k)-x(inx1)) / (x(inx2) - x(inx1));
end



% -------------------------------------------------------------------------
% SEGMENTATION
% -------------------------------------------------------------------------
function sne = seglim(ip)

% Makes disjuct intervals from a set of points
drml = diff(ip);
fdr = find(drml>1);
lenfdr = length(fdr);
prepa = zeros(2,lenfdr+1);
prepa(1,1) = ip(1);
for t = 1:lenfdr
    prepa(2,t) = ip(fdr(t));
    prepa(1,t+1) = ip(fdr(t)+1);
end
prepa(2,end) = ip(end);
sne = prepa;



% -------------------------------------------------------------------------
% PLOT & SAVE
% -------------------------------------------------------------------------
function H = plotsave(vv)

H = figure;
hold on
plot(vv','.')
plot(nanmean(vv))